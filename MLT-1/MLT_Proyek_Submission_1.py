# -*- coding: utf-8 -*-
"""MLT - Proyek Submission 1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jFen8I8t8d3IMiiOi5BIVzq3xwjh7YNw

# **Analisis Prediktif**: Prediksi Data Air yang Dapat Dikonsumsi Manusia
---
##### Oleh : [Fahmi Jabbar](https://www.dicoding.com/users/fahmijabbar)
##### Proyek Submission 1 - Machine Learning Terapan Dicoding

![Sumber : https://www.un.org/sustainabledevelopment/wp-content/uploads/2019/07/E_Infographic_06.pdf](https://user-images.githubusercontent.com/58651943/133801531-33e0b221-e741-406b-97f5-cbf455ad4bd1.png)

# **Pendahuluan**

Pada proyek ini, topik yang dibahas adalah mengenai `kesehatan` yang di buat untuk memprediksi data air yang dapat dikonsumsi manusia. Proyek ini dibuat untuk proyek Submission 1 - Machine Learning Terapan Dicoding. Untuk memudahkan navigasi di halaman, silahkan gunakan menu `Table of Contents` di kiri atas halaman.

# **1. Mengimpor pustaka/modul python yang dibutuhkan**
"""

# Memasang modul plotly & scikit-learn terbaru
!pip install -U plotly
!pip install -U scikit-learn

# Untuk pengolahan data
import pandas as pd
from sklearn.preprocessing import MinMaxScaler
from sklearn.model_selection import train_test_split
from sklearn.utils import resample 

# Untuk visualisasi data
import plotly.express as px
import missingno as msno

# Untuk pembuatan model 
from sklearn.neighbors import KNeighborsClassifier
from sklearn.neighbors import LocalOutlierFactor
from sklearn.experimental import enable_halving_search_cv
from sklearn.model_selection import HalvingGridSearchCV, StratifiedKFold


# Untuk evaluasi model
from sklearn.metrics import confusion_matrix, classification_report

"""# **2. Mempersiapkan Dataset**

## 2.1 Menyiapkan kredensial akun Kaggle
"""

# Membuat folder .kaggle di dalam folder root
!rm -rf ~/.kaggle && mkdir ~/.kaggle/

# Menyalin berkas kaggle.json pada direktori aktif saat ini ke folder .kaggle
!mv kaggle.json ~/.kaggle/kaggle.json
!chmod 600 ~/.kaggle/kaggle.json

"""## 2.2 Mengunduh dan Menyiapkan Dataset

![Sampul Dataset](https://user-images.githubusercontent.com/58651943/133802226-a7f08f75-0cf0-4b6b-8384-678cf09b15dd.png)

Informasi Dataset :

Jenis | Keterangan
--- | ---
Sumber | [Kaggle Dataset : Water Quality](https://www.kaggle.com/adityakadiwal/water-potability)
Lisensi | CC0: Public Domain
Kategori | Lingkungan, Bumi dan Alam, Kesehatan Publik
Rating Penggunaan | 10.0 (Gold)
Jenis dan Ukuran Berkas | CSV (525 kb)
"""

# Mengunduh dataset menggunakan Kaggle CLI
!kaggle datasets download -dadityakadiwal/water-potability

# Mengekstrak berkas zip ke direktori aktif saat ini
!unzip /content/water-potability.zip

"""# **3. Pemahaman Data** ***(Data Understanding)***

## 3.1 Memuat Data pada sebuah Dataframe menggunakan *pandas*
"""

df = pd.read_csv("/content/water_potability.csv")

"""## 3.2 Keterangan kolom pada dataset"""

# Memuat informasi dataframe
df.info()

# Menghitung jumlah data kosong pada setiap kolom
df.isna().sum()

"""<details>
  <summary>Buka untuk penjelasan<h4><b>Penjelasan :</b></h4></summary>
Berkas `water_potability.csv` berisi informasi metriks kualitas air untuk 3276 jenis air yang berbeda. Terdapat 9 buah data numerik (tipe data float64) dan 1 buah data kategori (tipe data int64). Terdapat juga beberapa kolom yang memiliki data kosong diantaranya pada kolom `pH`, `Sulfate` dan `Trihalomethanes`
</details>
"""

# Memuat deskripsi setiap kolom dataframe
df.describe()

"""<details>
  <summary>Buka untuk penjelasan<h4><b>Penjelasan :</b></h4></summary>
Berkas `water_potability.csv` memiliki 10 kolom diantaranya :

1. `pH` Parameter penting dalam mengevaluasi keseimbangan asam-basa air. Pada data ini nilainya berada pada rentang 0-14. Tingkat pH untuk air yang dapat dikonsumsi menurut rekomendasi WHO adalah 6.5 - 8.5

2. `Hardness` Kesadahan air/Air keras didefinisikan sebagai kapasitas air untuk mengendapkan sabun yang disebabkan oleh Kalsium dan Magnesium. Pada kolom ini kapasitas air untuk mengendapkan sabun ditulis dalam satuan mg/L

3. `Solids` Kemampuan air untuk melarutkan berbagai mineral atau garam organik dan anorganik, ditulis dalam satuan ppm. Untuk keperluan air minum batasnya adalah antara 500-1000 mg/L

4. `Chloramines` Kandungan Klorin/kloramin yang merupakan disinfektan utama yang digunakan dalam sistem air publik, ditulis dalam satuan ppm. Kadar klorin yang baik untuk air minum adalah kurang dari 4 ppm

5. `Sulfate` Kandungan sulfat yang merupakan zat alami yang ditemukan di mineral, tanah, dan batuan. Data ini ditulis dalam satuan mg/L. Kadar sulfat yang ada pada air bersih berkisar antara 3-30 mg/L

6. `Conductivity` Kemampuan air dalam menghantarkan listrik, yang ditulis dalam satuan μS/cm. Pada air minum, nilai konduktivitas air harus berada dibawah 400 μS/cm

7. `Organic_carbon` Kandungan karbon dalam senyawa organik, ditulis dalam satuan ppm. Menurut US EPA kandungan yang kurang dari 2 mg/L dapat digunakan sebagai air olahan/minum

8. `Trihalomethanes` Kandungan Trihalomethanes (THM) yang biasa ditemukan pada air yang diolah dengan klorin. Kadar THM hingga 80 ppm dianggap aman untuk digunakan sebagai air minum

9. `Turbidity` Tingkat kekeruhan air yang diukur dengan tingkat pancaran cahaya pada air dalam satuan NTU. Tingkat kekeruhan kurang dari 5.00 NTU dapat digunakan sebagai air minum menurut WHO

10. `Potability` Menentukan apakah air dapat diminum (nilai 1) atau tidak dapat diminum (nilai 0)
</details>

## 3.3 Visualisasi Data
"""

# Fungsi untuk plot distribusi data pada suatu kolom
def plot_distribution(column:str, title:str):
  figures = px.histogram(data_frame=df,
                        x=column,
                        color='Potability',
                        template='plotly_white',
                        marginal='box',
                        nbins=200,
                        color_discrete_sequence=["#FF7171","#9FD8DF"],
                        barmode='stack',
                        histfunc='count')

  figures.update_layout(font_family='Open Sans',
                        title=dict(text=title,
                                  x=0.47,
                                  font=dict(color="#333",size=20)),
                        hoverlabel=dict(bgcolor='white'))

  figures.show()

"""#### 3.3.1 Visualisasi data yang kosong"""

# Melakukan visualisasi data yang kosong
sorted_null = msno.nullity_sort(df, sort='descending') 
figures = msno.matrix(sorted_null, color=(1, 0.43, 0.43))

"""<details>
  <summary>Buka untuk penjelasan<h4><b>Penjelasan :</b></h4></summary>
Berdasarkan visualisasi data diatas, dapat kita lihat bahwa terdapat data yang kosong pada kolom-kolom yang ada saat menjalankan kode <code>df.isna().sum()</code>
</details>

#### 3.3.2 Distribusi data pada kolom dengan fitur numerik (pH, Hardness	Solids, Chloramines, Sulfate, Conductivity, Organic_carbon	Trihalomethanes, dan Turbidity)
"""

# Melakukan visualisasi data pada setiap kolom dengan fitur numerik
for column in df.columns:
  if(column == 'Potability'):
    break
  plot_distribution(column=column, title=f"Distribusi fitur numerik pada kolom {column}")

"""<details>
  <summary>Buka untuk penjelasan<h4><b>Penjelasan :</b></h4></summary>
Dari hasil visualisasi data diatas, kita dapat melihat distribusi data yang ada pada setiap kolom. Termasuk nilai minimum, median, maksimum, Q1, Q3, batas atas dan batas bawah. Selain itu kita juga dapat melihat beberapa nilai <i>outliers</i> atau data pencilan pada setiap kolomnya.
</details>

#### 3.3.3 Distribusi kelas pada kolom dengan fitur kategori (Potability)
"""

potability_data = pd.DataFrame(df['Potability'].value_counts())
figures = px.pie(data_frame=potability_data,
             values='Potability',
             names=['Not Potable','Potable'],
             hole=0.4,
             color_discrete_sequence=["#FF7171","#9FD8DF"],
             labels={'label':'Potability','Potability':'No. Of Samples'})

figures.update_layout(font_family='Open Sans',
                      title=dict(text='Distribusi kelas pada kolom potability',
                                 x=0.49,
                                 y=0.95,
                                 font=dict(color="#333",size=20)),
                      hoverlabel=dict(bgcolor='white'))

figures.update_traces(textposition='outside', textinfo='percent+label')

figures.show()

"""<details>
  <summary>Buka untuk penjelasan<h4><b>Penjelasan :</b></h4></summary>
Dari hasil visualisasi data diatas, kita dapat melihat persebaran data pada kategori Potability tidak seimbang atau disebut juga <i>data imbalance</i> 
</details>

#### 3.3.3 Korelasi data antar kolom dengan fitur numerik
"""

# Visualisasi matrix dari korelasi data
figures = px.scatter_matrix(data_frame=df, 
                            dimensions=df.drop('Potability',axis=1),
                            template='plotly_white',
                            color="Potability",
                            symbol="Potability",
                            color_discrete_sequence=["#FF7171","#9FD8DF"],
                            color_continuous_scale=["#FF7171","#9FD8DF"],
                            height=1500)

figures.update_layout(font_family='Open Sans',
                      font_size=10,
                      title=dict(text='Korelasi data antar kolom (fitur numerik) - Visualisasi Matrix',
                                 x=0.49,
                                 y=0.98,
                                 font=dict(color="#333",size=20)),
                      hoverlabel=dict(bgcolor='white'),
                      coloraxis_showscale=False)

figures.update_traces(diagonal_visible=False)

figures.show()

# Mempersiapkan dataframe korelasi data antar kolom
correlations_data=df.drop('Potability',axis=1).corr()
correlations_data

# Visualisasi heatmap dari korelasi data
# semakin mendekati 1 semakin tinggi korelasi datanya
# semkain mendekati -1 semakin rendah korelasi datanya
figures = px.imshow(correlations_data,
                    color_continuous_scale=["#FF7171","#9FD8DF"])

figures.update_layout(font_family='Open Sans',
                      font_size=10,
                      title=dict(text='Korelasi data antar kolom (fitur numerik) - Visualisasi Heatmap',
                                 x=0.49,
                                 y=0.98,
                                 font=dict(color="#333",size=20)),
                      hoverlabel=dict(bgcolor='white'))

figures.show()

"""<details>
  <summary>Buka untuk penjelasan<h4><b>Penjelasan :</b></h4></summary>
Apabila nilai korelasi (z) mendekati 1 maka korelasi data antar kolom termasuk tinggi dan baik untuk digunakan dalam fitur model klasifikasi. Namun dari hasil visualisasi diatas menunjukan bahwa semua kolom tidak memiliki korelasi yang tinggi antar sesama kolomnya.
</details>

# **4. Persiapan Data** ***(Data Preparation)***

## 4.1 Mengatasi masalah data yang kosong dengan nilai rata-rata kolom _(mean substitution)_
"""

# Rata-rata data pada kolom yang memiliki data kosong, dengan kondisi kolom Potability = 0
df[df['Potability']==0][['ph','Sulfate','Trihalomethanes']].mean()

# Rata-rata data pada kolom yang memiliki data kosong, dengan kondisi kolom Potability = 1
df[df['Potability']==1][['ph','Sulfate','Trihalomethanes']].mean()

# Rata-rata data pada kolom yang memiliki data kosong (data keseluruhan)
df[['ph','Sulfate','Trihalomethanes']].mean()

"""<details>
  <summary>Buka untuk penjelasan<h4><b>Penjelasan :</b></h4></summary>
Karena nilai rata-rata data kosong dengan kondisi kolom Potability 1 atau 0 memiliki rentang yang cukup jauh. Maka dipilih nilai rata-rata pada keseluruhan datanya.
</details>
"""

# Melakukan penggantian data kosong dengan nilai rata rata kolom 
# dan memasukkannya pada variabel df
df['ph'].fillna(value=df['ph'].mean(),inplace=True)
df['Sulfate'].fillna(value=df['Sulfate'].mean(),inplace=True)
df['Trihalomethanes'].fillna(value=df['Trihalomethanes'].mean(),inplace=True)

# Mengecek kembali nilai yang kosong pada dataset
df.isna().sum()

# Mengecek total baris dan kolom dari dataset
df.shape

"""Dengan demikian, data yang kosong sudah terisi dengan nilai rata-rata dari kolomnya"""

# Mengecek total baris dan kolom dari dataset
df.shape

"""## 4.2 Mengatasi masalah data tidak seimbang dengan resample"""

# Menghitung label dari kolom potability
df.Potability.value_counts()

"""<details>
  <summary>Buka untuk penjelasan<h4><b>Penjelasan :</b></h4></summary>
Karena data dengan label 1 (Potability) memiliki data yang lebih sedikit, maka label ini perlu dilakukan resample atau upsampling.
</details>
"""

# Memilih setiap labelnya
zero  = df[df['Potability']==0]
one = df[df['Potability']==1]

# Melakukan resample sehingga banyak data pada label = 1
# adalah 1988
df_minority_resampled = resample(one, replace = True, n_samples = 1998)

# Memasukan datanya pada dataframe
df = pd.concat([zero, df_minority_resampled])

# Menghitung label dari kolom potability
df.Potability.value_counts()

"""## 4.3 Melakukan pembagian data pada dataset dengan train_test_split"""

X = df.drop('Potability',axis=1).values
y = df['Potability'].values

# Melakukan pembagian data dengan train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=404, stratify=y)

"""<details>
  <summary>Buka untuk penjelasan<h4><b>Penjelasan :</b></h4></summary>
Pembagian dataset kepada 80% data latih dan 20% data uji + Memerhatikan pembagian data label (y) pada kedua data agar seimbang
</details>
"""

# Mengecek jumlah baris pada data latih dan data 
print(X_train.shape)
print(X_test.shape)

"""## 4.4 Mengatasi data pencilan pada data latih dengan metode LOF _(Local Outlier Factor)_"""

# Inisialisasi fungsi LocalOutlierFactor
lof = LocalOutlierFactor().fit_predict(X_train)

# Memilih semua baris yang bukan outlier
# Memasukannya kembali kedalam dataset
mask = lof != -1
X_train, y_train = X_train[mask, :], y_train[mask]

X_train.shape

"""<details>
  <summary>Buka untuk penjelasan<h4><b>Penjelasan :</b></h4></summary>
Nilai pencilan merupakan nilai yang tidak normal pada dataset dan dapat mengakibatkan distorsi pada analisis statistika dan berujung pada pembuatan model yang kurang optimal. Maka dari itu, pada bagian ini diterapkan metode Local Outlier Factor untuk mendeteksi nilai outlier dan kemudian menghapusnya dari data latih. Mengapa data latih saja? Agar kita dapat melihat bagaimana performa model pada data yang belum pernah dilihat model sebelumnya.
</details>

## 4.5 Standarisasi nilai data pada fitur numerik dengan MinMaxScaler
"""

# Inisialisasi fungsi MinMaxScaler
scaler = MinMaxScaler()

X_train = scaler.fit_transform(X_train)
X_test = scaler.fit_transform(X_test)

# Melihat sampel hasil standarisasi data
print(f"{X_train[0:3]} \n")
print(X_test[0:3])

"""<details>
  <summary>Buka untuk penjelasan<h4><b>Penjelasan :</b></h4></summary>
Dengan melakukan standarisasi data, kita telah membuat semua fitur numerik berada dalam skala data yang sama juga membuat komputasi dari pembuatan model dapat berjalan lebih cepat karena rentang datanya hanya antara 0-1.
</details>
"""

# Mengecek jumlah baris pada data latih dan data 
print(X_train.shape)
print(X_test.shape)

"""# **5. Pembuatan Model**

## 5.1 Model Baseline dengan Algoritma K-Nearest Neighbors
"""

# Pembuatan model baseline
baseline_model = KNeighborsClassifier()
baseline_model.fit(X_train, y_train)

# Pengujian model terhadap data test
y_pred = baseline_model.predict(X_test)

# Laporan hasil klasifikasi model baseline
baseline_report = classification_report(y_test, y_pred, output_dict=True, target_names=['Not Potable',"Potable"])
pd.DataFrame(baseline_report).transpose()

"""<details>
  <summary>Buka untuk penjelasan<h4><b>Penjelasan :</b></h4></summary>
Model baseline yang dibuat memiliki akurasi yang kurang baik, begitu juga  nilai precision, recall dan f1-score pada setiap labelnya.
</details>
"""

# Menyimpan hasil prediksi untuk confussion matrix
baseline_cf = confusion_matrix(y_test, y_pred)

"""## 5.2 Pengembangan Model K-Nearest Neighbors dengan Hyper Parameter Tuning menggunakan HalvingGridSearchCV"""

# Hyperparameter yang akan di tuning
param_grid = {'n_neighbors': [1, 2],
              'p': [1, 2],
              'weights': ["uniform","distance"],
              'algorithm':["ball_tree", "kd_tree", "brute"],
              }

# Pencarian parameter terbaik dengan HalvingGridSearchCV
new_param = HalvingGridSearchCV(baseline_model, 
                                param_grid, 
                                cv=StratifiedKFold(n_splits=4, random_state=404, shuffle=True),
                                resource='leaf_size',
                                max_resources=20,
                                scoring='accuracy',
                                aggressive_elimination=True).fit(X_train, y_train)

# Hasil hyperparameter tuning dengan skor terbaik yang di dapatkan
print(f"Best parameter {new_param.best_estimator_} with score {new_param.best_score_}")

"""<details>
  <summary>Buka untuk penjelasan<h4><b>Penjelasan :</b></h4></summary>
Dari hasil diatas, dapat kita lihat bahwa dengan model KNN kita dapat membuat model yang memiliki akurasi yang lebih baik lagi setelah di atur hyperparameternya.
</details>
"""

# Penerapan hyperparameter pada model baseline
model = KNeighborsClassifier(algorithm='ball_tree', leaf_size=3, n_neighbors=1)
model.fit(X_train, y_train)

# Pengujian model terhadap data test
y_pred = model.predict(X_test)

# Laporan hasil klasifikasi model baseline
improvement_report = classification_report(y_test, y_pred, output_dict=True, target_names=['Not Potable',"Potable"])
pd.DataFrame(improvement_report).transpose()

"""<details>
  <summary>Buka untuk penjelasan<h4><b>Penjelasan :</b></h4></summary>
Dari hasil diatas, model yang telah di atur hyperparameternya memiliki akurasi yang jauh lebih baik daripada sebelumnya. Begitupun nilai precision, recall dan f1-score pada setiap kelasnya.
</details>
"""

# Menyimpan hasil prediksi untuk confussion matrix
improvement_cf = confusion_matrix(y_test, y_pred)

"""# **6. Evaluasi Model**

## 6.1 Perbandingan metriks antara model baseline dengan model yang dikembangkan
"""

# Memasukkan hasil laporan klasifikasi model pada dataframe
metrics = pd.DataFrame({'accuracy' : [baseline_report['accuracy'], improvement_report['accuracy']],
                        'f1-score_0' : [baseline_report['Not Potable']['f1-score'],improvement_report['Not Potable']['f1-score']],
                        'precision_0' : [baseline_report['Not Potable']['precision'],improvement_report['Not Potable']['precision']],
                        'recall_0' : [baseline_report['Not Potable']['recall'],improvement_report['Not Potable']['recall']],
                        'f1-score_1' : [baseline_report['Potable']['f1-score'],improvement_report['Potable']['f1-score']],
                        'precision_1' : [baseline_report['Potable']['precision'],improvement_report['Potable']['precision']],
                        'recall_1' : [baseline_report['Potable']['recall'],improvement_report['Potable']['recall']]},
                        index=['Model Baseline','Model yang Dikembangkan'])
multiheader = [('','accuracy'),
               ('Not Potable', 'f1-score'),
               ('Not Potable', 'precision'),
               ('Not Potable', 'recall'),
               ('Potable', 'f1-score'),
               ('Potable', 'precision'),
               ('Potable', 'recall')]
metrics.columns = pd.MultiIndex.from_tuples(multiheader)
# Menampilkan dataframe
metrics

"""## 6.2 Confussion Matrix"""

# Visualisasi hasil prediksi model baseline
figures = px.imshow(baseline_cf,
                    labels=dict(x="Label 1", y="Label 2", color="Terprediksi"),
                    x=['Not Potable', 'Potable'],
                    y=['Not Potable', 'Potable'],
                    color_continuous_scale=["#FF7171","#9FD8DF"])

figures.update_layout(font_family='Open Sans',
                      font_size=10,
                      title=dict(text='Confussion Matrix - Model Baseline',
                                 x=0.49,
                                 y=0.98,
                                 font=dict(color="#333",size=20)),
                      hoverlabel=dict(bgcolor='white'),
                      coloraxis_showscale=False
                      )
figures.show()

# Visualisasi hasil prediksi model yang dikembangkan
figures = px.imshow(improvement_cf,
                    labels=dict(x="Label 1", y="Label 2", color="Terprediksi"),
                    x=['Not Potable', 'Potable'],
                    y=['Not Potable', 'Potable'],
                    color_continuous_scale=["#FF7171","#9FD8DF"])

figures.update_layout(font_family='Open Sans',
                      font_size=10,
                      title=dict(text='Confussion Matrix - Model yang dikembangkan',
                                 x=0.49,
                                 y=0.98,
                                 font=dict(color="#333",size=20)),
                      hoverlabel=dict(bgcolor='white'),
                      coloraxis_showscale=False)
figures.show()

"""<details>
  <summary>Buka untuk penjelasan<h4><b>Penjelasan :</b></h4></summary>
Dari kedua hasil visualisasi prediksi dengan confussion matrix diatas, kita dapat melihat bahwa performa model yang dikembangkan pada data uji lebih baik daripada model baselinenya dan dapat digunakan untuk memprediksi data. Dengan demikian, tujuan pembuatan model untuk menentukan apakah air layak untuk dikonsumsi oleh manusia bisa tercapai.
</details>

# Penutupan

Model untuk memprediksi data air yang layak di konsumsi oleh manusia telah selesai dibuat dan model ini dapat digunakan untuk memprediksi data sebenarnya. Namun demikian beberapa pengembangan lain masih dapat dilakukan agar membuat model yang memiliki akurasi lebih tinggi lagi seperti dengan mencoba penggunaan algoritma lainnya dalam membuat model seperti Random Forest, Decision Tree, Gradient Boosting dan masih banyak lagi.


### *Referensi*
- Dokumentasi Scikit-learn : https://scikit-learn.org/stable/modules/classes.html
- Dokumentasi Plotly : https://plotly.com/python/
- Lainnya :
  - https://www.kaggle.com/jaykumar1607/water-quality-analysis-plotly-and-modelling
  - https://www.kaggle.com/sohommajumder21/7-models-with-params-tuning-beginner-friendly
  - https://www.kaggle.com/d4rklucif3r/water-quality-eda-luciferml-76-accuracy
  - https://www.kaggle.com/gcmadhan/water-quality-prediction-76-h2o-80-accuracy
"""