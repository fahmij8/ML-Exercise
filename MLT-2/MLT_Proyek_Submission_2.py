# -*- coding: utf-8 -*-
"""MLT - Proyek Submission 2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1tgracP8XWf-oFmj6DuVJl4cQsw-S75t4

# **Sistem Rekomendasi**: Rekomendasi Aplikasi untuk Pengguna di Google Play Store
---
##### Oleh : [Fahmi Jabbar](https://www.dicoding.com/users/fahmijabbar)
##### Proyek Submission 2 - Machine Learning Terapan Dicoding

# **Pendahuluan**

Pada proyek ini akan dibuat sistem rekomendasi aplikasi untuk pengguna di Google Play Store menggunakan *content-based filtering*. Untuk memudahkan navigasi gunakan menu *Table of Contents* di kanan atas Google Colaboratory.

# **1. Mengimpor pustaka/modul python yang dibutuhkan**
"""

# Memasang modul plotly & scikit-learn terbaru
!pip install -U plotly
!pip install -U scikit-learn

# Untuk pengolahan data
import numpy as np
import pandas as pd
from sklearn.preprocessing import MinMaxScaler
from sklearn.impute import KNNImputer

# Untuk visualisasi data
import plotly.express as px
from plotly.offline import iplot
import missingno as msno

# Untuk pembuatan sistem rekomendasi 
from sklearn.neighbors import NearestNeighbors
from sklearn.metrics.pairwise import cosine_similarity

# Untuk evaluasi sistem rekomendasi
from sklearn.metrics import calinski_harabasz_score, davies_bouldin_score

"""# **2. Mempersiapkan Dataset**

## 2.1 Menyiapkan kredensial akun Kaggle
"""

# Membuat folder .kaggle di dalam folder root
!rm -rf ~/.kaggle && mkdir ~/.kaggle/

# Menyalin berkas kaggle.json pada direktori aktif saat ini ke folder .kaggle
!mv kaggle.json ~/.kaggle/kaggle.json
!chmod 600 ~/.kaggle/kaggle.json

"""## 2.2 Mengunduh dan Menyiapkan Dataset

![Sampul Dataset](https://user-images.githubusercontent.com/58651943/134548111-e092e12e-7621-4b61-86c5-3bc32bcbbfeb.png)

Informasi Dataset :

Jenis | Keterangan
--- | ---
Sumber | [Kaggle Dataset : Google Play Store Apps](https://www.kaggle.com/adityakadiwal/water-potability)
Lisensi | Creative Commons Attribution 3.0
Kategori | Bisnis, Internet, Sains Komputer 
Rating Penggunaan | 7.1 (Gold)
Jenis dan Ukuran Berkas | zip (9 MB)
"""

# Mengunduh dataset menggunakan Kaggle CLI
!kaggle datasets download -d lava18/google-play-store-apps

# Mengekstrak berkas zip ke direktori aktif saat ini
!unzip /content/google-play-store-apps.zip

"""# **3. Pemahaman Data** ***(Data Understanding)***

## 3.1 Memuat Data pada sebuah Dataframe menggunakan *pandas*
"""

# Memuat data pada dataframe di variable df dari file googleplaystore.csv
df = pd.read_csv("/content/googleplaystore.csv")

# Pratinjau dataset
df.tail(3)

"""## 3.2 Uraian variabel pada dataset"""

# Memuat informasi dataframe
df.info()

# Menghitung jumlah data kosong pada setiap kolom
df.isna().sum()

# Memvisualisasikan data kosong pada setiap kolom
sorted_null = msno.nullity_sort(df, sort='ascending') 
figures = msno.matrix(sorted_null, color=(1, 0.43, 0.43))

"""<details>
  <summary>Buka untuk penjelasan<h4><b>Penjelasan :</b></h4></summary>

Berkas <code>googleplaystore.csv</code> berisi informasi mengenai detail aplikasi yang ada di Google Play Store. Namun pada datanya masih terdapat banyak sekali nilai kosong seperti pada kolom <code>Rating</code>, <code>Type</code>, <code>Content Rating</code>, <code>Current Ver</code> dan <code>Android Ver</code> 

Kemudian berikut adalah uraian variabel dari setiap kolom pada data : 

1. Kolom <code>App</code> merupakan kolom dengan data nama dari aplikasi.

2. Kolom <code>Category</code> merupakan kolom dengan data jenis kategori dari aplikasi.

3. Kolom <code>Rating</code> merupakan kolom dengan data penilaian pengguna dari aplikasi dalam satuan bintang.

4. Kolom <code>Reviews</code> merupakan kolom dengan data jumlah pengguna yang telah memberi ulasan pada aplikasi

5. Kolom <code>Size</code> merupakan kolom dengan data ukuran dari aplikasi dalam satuan byte.

6. Kolom <code>Installs</code> merupakan kolom dengan data jumlah pengguna yang telah mengunduh dan memasang aplikasi.

7. Kolom <code>Type</code> merupakan kolom dengan data jenis aplikasi yang hanya berisi 2 kategori yakni <i>Paid</i>/berbayar dan <i>Free</i>/gratis.

8. Kolom <code>Price</code> merupakan kolom dengan data harga dari aplikasi dalam satuan dollar.

9. Kolom <code>Content Rating</code> merupakan kolom dengan data kategori usia penggunaan untuk aplikasi, seperti <i>children</i>/<i>adult</i> dsb.

10. Kolom <code>Genres</code> merupakan kolom dengan data kategori dari genre aplikasi. Setiap aplikasi bisa saja memiliki dua genre yang berbeda.

11. Kolom <code>Last Updated</code> merupakan kolom dengan data tanggal terakhir aplikasi di perbaharui oleh pengembang.

12. Kolom <code>Current Ver</code> merupakan kolom dengan data versi terkini aplikasi.

13. Kolom <code>Android Ver</code> merupakan kolom dengan data versi android (minimal) yang dibutuhkan untuk memasang aplikasi.

Selanjutnya, akan dilakukan visualisasi data. Namun, ada beberapa kolom yang perlu diubah tipe datanya seperti kolom <code>Reviews</code>, <code>Install</code>, <code>Price</code>, dan <code>Size</code> pada satuan <i>integer</i>. Lalu kolom <code>Last Updated</code> yang perlu diubah tipe datanya ke <i>datetime</i>. Maka dari itu bagian visualisasi data disatukan dengan bagian persiapan data.
</details>

# **4. Persiapan Data** ***(Data Preparation)*** **dan Visualisasi Data**

## 4.1 Pembersihan data pada setiap kolom

### 4.1.1 Kolom Rating
"""

# Melihat data unik pada kolom rating
df['Rating'].unique()

# Mencari data rating yang nilainya lebih dari 5
df[df['Rating']>5]

"""<details>
  <summary>Buka untuk penjelasan<h4><b>Penjelasan :</b></h4></summary>

Berdasarkan data unik dari kolom <i>rating</i> terdapat 2 hal yang janggal. Diantanya :

1. Terdapat nilai <i>rating</i> yang lebih dari 5. Maka untuk bagian ini akan dilakukan penghapusan data, karena hanya terdapat 1 data saja yang seperti ini.

2. Terdapat data NaN/kosong pada kolom <i>rating</i>. Untuk bagian ini akan diselesaikan dengan cara melakukan imputasi data dengan KNNImputer. Dengan cara ini, distribusi data rating akan tetap terjaga pada setiap fitur.


</details>
"""

# Melakukan penghapusan baris pada index 10472
df.drop(df.index[10472], axis=0, inplace=True)

# Mencari kembali data rating yang nilainya lebih dari 5
if(len(df[df['Rating']>5]) == 0):
  print("Data rating dengan nilai > 5 sudah dihapus")
else:
  print("Data rating dengan nilai > 5 belum dihapus")

# Inisiasi objek KNNImputer dengan nilai tentangga = 5 (sesuai setelan awal)
# Dimana 5 merepresentasikan rentang rating
imputer = KNNImputer()

# Melakukan imputasi pada nilai NaN
df['Rating'] = imputer.fit_transform(df[['Rating']]).ravel()
# Membulatkan nilai hasil imputasi dengan 1 koma
df['Rating'] = df['Rating'].round(decimals=1)

# Mencari data rating yang nilainya kosong

if(df['Rating'].isna().sum() == 0):
  print("Data rating dengan nilai NaN sudah diimputasi")
else:
  print("Data rating dengan nilai NaN belum diimputasi")

"""### 4.1.2 Kolom Reviews"""

# Mengubah tipe data kolom reviews menjadi integer
df["Reviews"] = df["Reviews"].astype(int)
df.info()

"""<details>
  <summary>Buka untuk penjelasan<h4><b>Penjelasan :</b></h4></summary>

Tipe data kolom Reviews diubah agar sesuai dengan isi dari kolom Reviews, yakni jumlah pengguna yang mengulas aplikasinya.

</details>

### 4.1.3 Kolom Size
"""

# Melihat data unik pada kolom Size
df['Size'].unique()

# Mengganti nilai pada kolom size
# Menyesuaikan nilai Megabyte
df['Size']= df['Size'].str.replace('M','000')
# Menyesuaikan nilai Kilobyte
df['Size'] = df['Size'].str.replace('k','')
# Mengganti nilai Varies with device menjadi 0
df['Size'] = df['Size'].replace("Varies with device",'0')
# Mengganti tipe data kolom size
df['Size'] = df['Size'].astype('float')

# Mengkonversi seluruh nilai size pada megabyte
for item in df['Size']:
  # Penyesuaian nilai untuk aplikasi dengan ukuran yang kecil
  if item < 10:
      df['Size'] = df['Size'].replace(item, item*1000)
df['Size'] = df['Size']/1000

# Pratinjau hasil
df['Size'].head(3)

# Melihat kembali informasi dataframe
df.info()

"""<details>
  <summary>Buka untuk penjelasan<h4><b>Penjelasan :</b></h4></summary>

Agar kolom size dapat dirubah ke tipe data angka, maka perlu dilakukan pemrosesan data. Pertama, setiap akhiran k dan M pada data Size diganti dengan angka, lalu tipe datanya dirubah menjadi <i>float</i>. Setelah itu semua nilai size dikonversi kedalam nilai mega byte.

</details>

### 4.1.4 Kolom Installs
"""

# Melihat data unik pada kolom Installs
df['Installs'].unique()

# Menghapus simbol + dan ,
df['Installs'] = df['Installs'].str.replace('+', '')
df['Installs'] = df['Installs'].str.replace(',', '')
# Mengubah tipe data kolom Installs
df['Installs'] = df['Installs'].astype('int')

# Melihat data unik pada kolom Installs
df['Installs'].unique()

# Mengecek informasi dataframe
df.info()

"""<details>
  <summary>Buka untuk penjelasan<h4><b>Penjelasan :</b></h4></summary>

Agar kolom Installs dapat dirubah ke tipe data angka, maka symbolnya perlu dihilangkan. Setelah itu baru di konversi tipe datanya menjadi integer

</details>

### 4.1.5 Kolom Type
"""

# Melihat jumlah data kosong pada kolom Type
df['Type'].isna().sum()

# Mencari data Type = NaN
df[df['Type'].isna()]

# Menghapus data NaN
for index in df[df['Type'].isna()].index:
  df.drop(index, axis=0, inplace=True)

# Mencari kembali data rating yang nilainya lebih dari 5
if(df['Type'].isna().sum() == 0):
  print("Data Type dengan nilai NaN sudah dihapus")
else:
  print("Data Type dengan nilai NaN belum dihapus")

# Mengecek informasi dataframe
df.info()

"""### 4.1.6 Kolom Price"""

# Melihat data unik pada kolom Installs
df['Price'].unique()

# Menghapus simbol $ 
df['Price'] = df['Price'].str.replace('$', '')
# Mengubah tipe data kolom Price
df['Price'] = df['Price'].astype('float')

# Melihat data unik pada kolom Installs
df['Price'].unique()

# Mengecek informasi dataframe
df.info()

"""<details>
  <summary>Buka untuk penjelasan<h4><b>Penjelasan :</b></h4></summary>

Agar kolom Price dapat dirubah ke tipe data angka, maka symbolnya perlu dihilangkan. Setelah itu baru di konversi tipe datanya menjadi float.

</details>

### 4.1.7 Kolom Last Updated
"""

# Mengubah tipe data kolom last updated
df['Last Updated'] = pd.to_datetime(df['Last Updated'])
# Melihat hasil perubahan tipe data
df.head(3)

# Mengecek informasi dataframe
df.info()

"""<details>
  <summary>Buka untuk penjelasan<h4><b>Penjelasan :</b></h4></summary>

Agar kolom Last Updated sesuai dengan isinya, maka diperlukan untuk mengubah tipe datanya menjadi <i>datetime</i>

</details>

### 4.1.8 Kolom Current Ver
"""

# Melihat jumlah data kosong pada kolom Current Ver
df['Current Ver'].isna().sum()

# Mencari data yang nilai Current Ver = NaN
df[df['Current Ver'].isna()]

# Menghapus data NaN
for index in df[df['Current Ver'].isna()].index:
  df.drop(index, axis=0, inplace=True)

df.info()

"""<details>
  <summary>Buka untuk penjelasan<h4><b>Penjelasan :</b></h4></summary>

Karena kolom current version merupakan kolom yang esensial bagi informasi aplikasinya, maka apabila dilakukan manipulasi data akan mengakibatkan disinformasi pada pengguna. Selain itu karena datanya sedikit, maka dihapus pun tidak mengapa karena kita tidak akan kehilangan banyak informasi dari data yang ada.

</details>

### 4.1.9 Kolom Android Ver
"""

# Melihat jumlah data kosong pada kolom Android Ver
df['Android Ver'].isna().sum()

# Mencari data yang nilai Android Ver = NaN
df[df['Android Ver'].isna()]

# Menghapus data NaN
for index in df[df['Android Ver'].isna()].index:
  df.drop(index, axis=0, inplace=True)

# Melihat informasi dataframe
df.info()

"""<details>
  <summary>Buka untuk penjelasan<h4><b>Penjelasan :</b></h4></summary>

Karena kolom android version merupakan kolom yang esensial bagi informasi aplikasinya, maka apabila dilakukan manipulasi data akan mengakibatkan disinformasi pada pengguna. Selain itu karena datanya sedikit, maka dihapus pun tidak mengapa karena kita tidak akan kehilangan banyak informasi dari data yang ada.

</details>

## 4.2 Pembersihan data duplikasi
"""

# Melihat jumlah data duplikasi
df.duplicated().sum()

# Menghapus data duplikasi
df.drop_duplicates(inplace=True)

# Melihat informasi dataframe
df.info()

"""<details>
  <summary>Buka untuk penjelasan<h4><b>Penjelasan :</b></h4></summary>

Data duplikasi pada sistem rekomendasi dapat menyebabkan munculnya data yang sama sebanyak 2 kali atau lebih. Dengan demikian agar tidak terjadi hal tersebut, datanya dihapus saja karena sebenarnya data tersebut sudah ada pada dataframe.

</details>
"""

# Hasil data setelah dibersihkan
df.head(5)

"""## 4.3 Visualisasi Data"""

# Fungsi untuk plot distribusi data pada suatu kolom numerik
def plot_distribution(column:str, title:str):
  figures = px.histogram(data_frame=df,
                        x=column,
                        color='Type',
                        template='plotly_white',
                        marginal='box',
                        color_discrete_sequence=["#FF7171","#9FD8DF"],
                        barmode='overlay',
                        histfunc='count')

  figures.update_layout(font_family='Open Sans',
                        title=dict(text=title,
                                  x=0.5,
                                  font=dict(color="#333",size=20)),
                        hoverlabel=dict(bgcolor='white'))

  figures.update_xaxes(
      automargin=True
  )

  iplot(figures)

# Fungsi untuk plot bar data pada suatu kolom numerik
def plot_bar(column:str, title:str):
  figures = px.bar(data_frame=df,
                  x="Category",
                  y=column, 
                  color="Type", 
                  barmode="group",
                  template='plotly_white',
                  color_discrete_sequence=["#FF7171","#9FD8DF"])

  figures.update_layout(font_family='Open Sans',
                        title=dict(text=title,
                                  x=0.5,
                                  font=dict(color="#333",size=20)),
                        hoverlabel=dict(bgcolor='white'))

  figures.update_xaxes(
      automargin=True
  )

  iplot(figures)

# Fungsi untuk plot pie data pada suatu kolom numerik
def plot_category(column:str, title:str):
  figures = px.sunburst(df,
                      path=["Type","Content Rating",column],
                      color="Installs", 
                      color_continuous_scale=["#9FD8DF","#FF7171"])

  figures.update_layout(font_family='Open Sans',
                        title=dict(text=title,
                                   x=0.5,
                                   font=dict(color="#333",size=20)),
                        title_y=0.96)

  figures.update_traces(hovertemplate="Labels = %{label}<br>Count = %{value}<br>Installed = %{color:.0f} <extra></extra>")

  figures.update_xaxes(
      automargin=True
  )

  iplot(figures)

"""### 4.3.1 Fitur Numerik"""

# Menampilkan visualisasi data
for column in ["Rating","Size"]:
    plot_distribution(column=column, title=f"Distribusi fitur numerik pada kolom {column}")

"""<details>
  <summary>Buka untuk penjelasan<h4><b>Penjelasan :</b></h4></summary>

Berdasarkan hasil visualisasi data diatas :

1. Untuk rating terbanyak dimiliki oleh aplikasi gratis, namun demikian rating tertinggi pada aplikasi gratis dan aplikasi berbayar sama yakni 4.2

2. Untuk size, pada data ini baik pada aplikasi gratis ataupun berbayar banyak yang ukuran aplikasinya < 2 mb

</details>
"""

# Menampilkan visualisasi data
for column in ["Reviews","Price"]:
    plot_bar(column=column, title=f"Distribusi label {column} dengan label kategori<br>Berdasarkan tipe aplikasi")

"""<details>
  <summary>Buka untuk penjelasan<h4><b>Penjelasan :</b></h4></summary>

Berdasarkan hasil visualisasi data diatas :

1. Untuk review terbanyak dimiliki oleh aplikasi gratis. Pada aplikasi gratis review terbanyak ada pada aplikasi game, sedangkan pada aplikasi berbayar review terbanyak ada pada aplikasi family

2. Untuk price, hanya ada pada kategori aplikasi berbayar dengan jenis aplikasi finance sebagai aplikasi dengan harga yang paling tinggi.

</details>

### 4.3.2 Fitur Kategori
"""

# Menampilkan visualisasi data
for column in ["Category","Genres"]:
    plot_category(column=column, title=f"Distribusi label {column}, Rating Aplikasi dan Tipe Aplikasi<br>Berdasarkan jumlah pengunduh")

# Klik area dalam chart untuk melihat persebaran data yang lebih lengkap

"""<details>
  <summary>Buka untuk penjelasan<h4><b>Penjelasan :</b></h4></summary>

Berdasarkan hasil visualisasi data diatas :

1. Ada banyak sekali yang informasi yang dapat disimpulkan pada kedua diagram diatas. Misalnya pada label Category, aplikasi yang paling banyak di unduh semua orang adalah aplikasi dengan kategori komunikasi. Begitupun pada label Genre. Untuk melihat informasi lebih detail, silahkan klik area bagian dalam diagram.

2. Label Genre dan Category memiliki data yang kurang lebih sama, perbedaannya label Genre memiliki informasi kategori aplikasi yang lebih detail.

</details>

## 4.4 Restrukturisasi Data

### 4.4.1 Menghapus kolom yang tidak diperlukan
"""

# Menghapus kolom Current Ver
df.drop('Current Ver',inplace=True,axis=1)
df.head()

# Menghapus kolom Last Updated
df.drop('Last Updated',inplace=True,axis=1)
df.head()

# Menyimpan nama-nama aplikasi pada dataframe baru
df_app_name = pd.DataFrame({'App':df['App']})
df_app_name.head()

# Menggunakan kolom aplikasi sebagai index
df.set_index('App',inplace=True)
df.head()

"""<details>
  <summary>Buka untuk penjelasan<h4><b>Penjelasan :</b></h4></summary>

Alasan beberapa kolom dihapus diantaranya :

1. Kolom Current Ver, dihapus karena nilainya terlalu variatif dan juga tidak terlalu penting bila dilihat dari sisi pengguna (Dengan asumsi pengguna hanya tertarik pada jenis aplikasi yang serupa saja). Selain itu juga kolom ini tidak merepresentasikan nilai versi aplikasi saat ini.

2. Kolom Last Updated, dihapus karena nilai tanggal disini merupakan tanggal ketika datanya didapatkan (scraping) dan bukan tanggal saat ini.

</details>

### 4.4.2 Konversi label kategori menjadi one-hot encoding
"""

# Memilih semua kolom dengan tipe data object
column_object = df.dtypes[df.dtypes == 'object'].keys()
column_object

# Mengkonversi data kategori ke one-hot encoding
one_hot_label = pd.get_dummies(df[column_object])
one_hot_label.head(3)

# Menghapus kolom dengan tipe data object
df.drop(column_object,axis=1,inplace=True)
df.head()

# Menyatukan one hot encoding dengan seluruh data
df = pd.concat([df,one_hot_label],axis=1)
df.head()

"""<details>
  <summary>Buka untuk penjelasan<h4><b>Penjelasan :</b></h4></summary>

Konversi label kategori menjadi one hot encoding dilakukan untuk memudahkan pencarian nilai terdekat antar sesama aplikasi.

</details>

### 4.4.2 Standarisasi label numerik
"""

# Memilih semua kolom dengan tipe data integer
column_int = df.dtypes[df.dtypes == 'int64'].keys()
column_int

# Memilih semua kolom dengan tipe data float
column_float = df.dtypes[df.dtypes == 'float64'].keys()
column_float

# Menyatukan semua kolom dengan tipe data numerik
column_numeric = list(column_int) + list(column_float)
column_numeric

# Inisiasi minmaxscaler
scaler = MinMaxScaler()

# Melakukan standarisasi data
scaled = scaler.fit_transform(df[column_numeric])

# Mengganti data numerik dengan data yang sudah
# di standarisasi
i=0
for column in column_numeric:
    df[column] = scaled[:,i]
    i += 1

# Melihat hasil standarisasi data
df.head()

# Menginspeksi data
df.describe()

"""<details>
  <summary>Buka untuk penjelasan<h4><b>Penjelasan :</b></h4></summary>

Standarisasi label numerik dilakukan agar rentang nilai pada label numerik hanya antara 0-1 sehingga dapat mempercepat komputasinya

</details>

# **5. Pembuatan Sistem Rekomendasi Content Based Filtering**

## 5.1 Dengan model K-Nearest Neighbor
"""

# Membuat sistem rekomendasi dengan model K-Nearest Neighbor
# Inisiasi model 
model = NearestNeighbors(metric='euclidean')

# Melakukan fitting model terhadap data
model.fit(df)

# Membuat fungsi untuk mendapatkan rekomendasi
# Dengan model KNN
def getRecommendedApps_model(appname:str, recommend_apps:int=5):
  print(f'Apabila pengguna menyukai aplikasi {appname[0]}\n5 aplikasi berikut ini juga mungkin akan disukai :')
  # Mencari aplikasi terdekat dengan aplikasi yang disukai pengguna
  distances, neighbors = model.kneighbors(df.loc[appname],n_neighbors=recommend_apps)
  # Memasukkan aplikasi yang sama pada sebuah list
  similar_app = []
  for appname in df_app_name.loc[neighbors[0][:]].values:
    similar_app.append(appname[0])
  # Memasukan skornya (jarak) pada sebuah list
  similar_distance = []
  for distance in distances[0]:
    similar_distance.append(f"{round(100-distance, 2)}%")
  # Mengembalikan sebuah dataframe berupa rekomendasi terhadap aplikasinya
  return pd.DataFrame(data = {"Nama Aplikasi" : similar_app, "Tingkat Kesamaan" : similar_distance})

# Memberikan rekomendasi terhadap aplikasi yang
# Serupa dengan Natural recipes for your beauty
getRecommendedApps_model(df_app_name.loc[100])

"""<details>
  <summary>Buka untuk penjelasan<h4><b>Penjelasan :</b></h4></summary>

Dengan model K-Nearest Neighbor, dimana K = 5. Kita dapat melihat hasil rekomendasinya terhadap suatu aplikasi. Bila dilihat secara seksama, hasilnya cukup baik karena relevan dengan aplikasi yang disukai pengguna.

</details>

## 5.2 Dengan Cosine Similarity
"""

# Menghitung cosine similarity dari dataframe
cosine_sim = cosine_similarity(df)

# Menyimpan hasil perhitungan pada dataframe
cosine_sim_df = pd.DataFrame(cosine_sim, index=df_app_name['App'], columns=df_app_name['App'])
cosine_sim_df.head(3)

# Membuat fungsi untuk mendapatkan rekomendasi
# Dengan Cosine Similarity
def getRecommendedApps_cosine(appname:str, recommended_apps:int=5):
  print(f'Apabila pengguna menyukai aplikasi {appname[0]}\n5 aplikasi berikut ini juga mungkin akan disukai :')
  # Mencari nilai unik pada aplikasi yang disukai pengguna di baris dataframe cosine sim
  # Nilai unik (arr) dikembalikan dalam bentuk yang berurutan dari kecil ke besar 
  arr, ind = np.unique(cosine_sim_df.loc[appname[0]], return_index=True)
  # Memasukkan nama aplikasi yang serupa dari index kedua terakhir sampai index n terakhir
  similar_app = []
  for index in ind[-(recommended_apps+1):-1]:
    similar_app.append(df_app_name.loc[index][0])
  # Memasukkan skor cosine dari aplikasi yang serupa mulai dari index kedua terakhir sampai index n terakhir
  cosine_score = []
  for score in arr[-(recommended_apps+1):-1]:
    cosine_score.append(score)
  # Mengembalikan sebuah dataframe berupa rekomendasi terhadap aplikasinya
  return pd.DataFrame(data = {"Nama Aplikasi" : similar_app, "Cosine Similarity" : cosine_score}).sort_values(by='Cosine Similarity',ascending=False)

# Memberikan rekomendasi terhadap aplikasi yang
# Serupa dengan Natural recipes for your beauty
getRecommendedApps_cosine(df_app_name.loc[100])

"""<details>
  <summary>Buka untuk penjelasan<h4><b>Penjelasan :</b></h4></summary>

Dengan cosine similarity. Kita dapat melakukan hal yang sama yakni membuat sistem rekomendasi terhadap aplikasi yang disukai pengguna. Namun disini dapat kita lihat ada 1 buah aplikasi yang kurang relevan dengan aplikasi yang disukai pengguna yakni CW Deposit (finance).

</details>

# **6. Evaluasi Model K-Nearest Neighbor**

## 6.1 Skor Calinski Harabasz
"""

calinski_harabasz_score(df, df_app_name)

"""<details>
  <summary>Buka untuk penjelasan<h4><b>Penjelasan :</b></h4></summary>

Skor Calinski Harabasz digunakan untuk menghitung kriteria rasio varian. Metriks ini digunakan pada model clustering seperti yang saat ini sedang digunakan. Skor semakin tinggi ketika cluster padat dan terpisah dengan baik. Pada model ini, nampaknya cluster masih belum padat dan terpisahkan dengan baik.

</details>

## 6.2 Skor Davies Bouldin
"""

davies_bouldin_score(df, df_app_name)

"""<details>
  <summary>Buka untuk penjelasan<h4><b>Penjelasan :</b></h4></summary>

Skor Davies Bouldin digunakan untuk menilai separasi tiap cluster dari model. Metriks ini digunakan pada model clustering seperti yang saat ini sedang digunakan. Skor rendah ketika separasi tiap cluster di model terpisahkan dengan baik. Pada model ini skornya cukup kecil sehingga menandakan modelnya sudah memiliki separasi cluster yang baik.

</details>

# Penutupan

Model untuk memberikan rekomendasi aplikasi untuk pengguna di Google Play Store telah selesai dibuat. Setelah diujikan, model ini bekerja cukup baik dalam memberikan 5 rekomendasi teratas terhadap aplikasi yang disukai/diunduh pengguna. Namun demikian, masih ada beberapa kekurangan dari model yang dibuat seperti yang terlihat pada skor Calinski Harabasz dan Davies Bouldin. Untuk memperbaikinya dapat digunakan algoritma untuk membuat model rekomendasi yang lain seperti menggunakan deep learning lalu dibandingkan performanya dengan model KNN saat ini.


### Referensi
- Dokumentasi Scikit-learn : https://scikit-learn.org/stable/modules/classes.html
- Dokumentasi Plotly : https://plotly.com/python/
- Lainnya :
  - https://www.kaggle.com/ahmedmohamedmahrous/google-play-store-eda
  - https://www.kaggle.com/ludovicocuoghi/google-store-deep-eda-rating-prediction-xgboost
  - https://www.kaggle.com/nandalald/android-app-recommendation
"""